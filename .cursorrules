# Multi-Agent SpecKit Orchestration Rules

## Core Principle
This project uses SpecKit with multi-agent coordination:
- **GPT-5**: Primary orchestrator (plans, coordinates, decides)
- **Qwen**: Implementation engineer (writes code, fast but needs supervision)
- **Claude**: Security reviewer & architect (reviews, has veto power)
- **Gemini**: Infrastructure specialist (cloud, databases, DevOps)

## When to Use SpecKit

### AUTO-TRIGGER SpecKit for:
- User says "implement", "build", "add feature", "create"
- Changes involve >3 files
- Any database/schema changes
- Security-sensitive code (auth, API keys, payments)
- Infrastructure changes (deployment, CI/CD)
- User mentions "backend + frontend" together

### DON'T use SpecKit for:
- Quick fixes (<10 lines)
- Typo corrections
- Documentation-only changes
- User explicitly says "quick fix, no speckit"

## Slash Command Workflow

### Step 1: /constitution (First time only)
Create project rules before any development.

**Example prompt:**
/constitution
Create principles for:

Code quality standards (TypeScript strict mode, testing required)
Security practices (no secrets in code, input validation)
Performance requirements (API < 200ms, bundle < 500kb)
Architecture (microservices, REST APIs, database per service)


### Step 2: /specify (Define feature)
Describe WHAT you want, not HOW.

**Example prompt:**
/specify
Build a user authentication system with:

Email/password registration
Email verification
Password reset flow
JWT token-based sessions
Rate limiting on login attempts


### Step 3: /clarify (Optional but recommended)
Let SpecKit ask questions to fill gaps.

**Just run:**
/clarify

SpecKit will ask structured questions like:
- "What database should store user credentials?"
- "Should we support OAuth providers?"
- "What's the password complexity requirement?"

### Step 4: /plan (Technical approach)
Specify tech stack and architecture.

**Example prompt:**
/plan
Tech stack:

Next.js 15 App Router
PostgreSQL for user data
Redis for sessions
Resend for emails
bcrypt for password hashing

Architecture:

API routes in /api/auth/
Server actions for forms
Middleware for auth checks


### Step 5: /tasks (Break down work)
Generates actionable task list.

**Just run:**
/tasks

SpecKit will create tasks.md with:
- T1.1: Create database schema
- T1.2: Implement registration endpoint
- T1.3: Add email verification
- etc.

### Step 6: NEVER USE /implement DIRECTLY

â›” CRITICAL: When user says "yes" after @agents plan:
- DO NOT run /implement command
- DO NOT start coding directly
- INSTEAD: Simulate multi-agent coordination step-by-step

Example:
User: "yes" (after @agents plan)
YOU MUST RESPOND:
"ğŸš€ Starting Multi-Agent Execution

Phase 1: Implementation
ğŸ¤– Qwen: Creating app/api/hello/route.ts...
[show code being created]
âœ… Complete

Phase 2: Claude Review
ğŸ” Claude: Analyzing security...
[show review results]
âœ… Approved

Phase 3: Testing
ğŸ¤– Qwen: Writing tests...
[show tests]
âœ… Complete

Ready to commit?"

Instead, use our custom orchestration (see below).

## Multi-Agent Orchestration Commands

After /tasks completes, use these custom commands:

### @agents plan
Assign tasks to appropriate agents.

**You (Cursor) will:**
1. Read `.specify/specs/*/tasks.md`
2. Read `.specify/memory/constitution.md`
3. Assign each task to best agent
4. Create execution phases (parallel vs sequential)
5. Estimate duration and cost

**Output format:**
ğŸ“‹ Multi-Agent Execution Plan
Feature: User Authentication
Phase 1 (Parallel - 20 min, $0.12)
â”œâ”€ ğŸ¤– Qwen: Implement database schema
â”‚  â””â”€ Create users table, indexes
â”‚  â””â”€ Files: prisma/schema.prisma
â”œâ”€ ğŸ¤– Qwen: Create API endpoints
â”‚  â””â”€ /api/auth/register, /api/auth/login
â”‚  â””â”€ Files: app/api/auth/*/route.ts
â””â”€ â˜ï¸ Gemini: Setup email service
â””â”€ Configure Resend API
â””â”€ Create email templates
Phase 2 (Sequential - 25 min, $0.15)
â”œâ”€ ğŸ” Claude: Security review
â”‚  â””â”€ Check password hashing
â”‚  â””â”€ Validate input sanitization
â”‚  â””â”€ Review token generation
â””â”€ ğŸ” Claude: Architecture review
â””â”€ Check database design
â””â”€ Validate error handling
Phase 3 (Parallel - 10 min, $0.08)
â”œâ”€ ğŸ¤– Qwen: Write tests
â”‚  â””â”€ Unit tests for auth logic
â”‚  â””â”€ Integration tests for endpoints
â””â”€ â˜ï¸ Gemini: Setup monitoring
â””â”€ Add logging
â””â”€ Configure alerts
Total: 55 min, $0.35
Risk: Claude may veto if security issues found
Approve? (yes/no/modify)

### @agents implement
Execute the plan with agent coordination.

**When user approves, you (Cursor) will:**
1. Execute Phase 1 tasks (simulate Qwen + Gemini)
2. Pause for Claude review
3. Handle Claude veto if security issue
4. Execute Phase 3
5. Show final summary

**Real-time output format:**
ğŸš€ Executing Multi-Agent Plan
Phase 1: Implementation
â”œâ”€ ğŸ¤– Qwen: Creating database schema...
â”‚  â””â”€ Generated prisma/schema.prisma (47 lines)
â”‚  â””â”€ Status: âœ… Complete (3 min)
â”œâ”€ ğŸ¤– Qwen: Implementing API endpoints...
â”‚  â””â”€ Created app/api/auth/register/route.ts (89 lines)
â”‚  â””â”€ Created app/api/auth/login/route.ts (67 lines)
â”‚  â””â”€ Status: âœ… Complete (12 min)
â””â”€ â˜ï¸ Gemini: Configuring email service...
â””â”€ Setup Resend API key in .env
â””â”€ Created lib/email.ts (34 lines)
â””â”€ Status: âœ… Complete (5 min)
Phase 1: Complete (20 min) âœ…
ğŸ”„ Starting Phase 2: Claude Review...
Phase 2: Security Review
ğŸ” Claude: Analyzing security...
âš ï¸ Issues Found:
ğŸ”´ CRITICAL: Password Stored in Plain Text
Location: app/api/auth/register/route.ts:45
Issue: await db.user.create({ password: body.password })
Attack: Database breach exposes all passwords
Fix Required: Use bcrypt.hash() before storing
ğŸŸ¡ MEDIUM: Missing Rate Limiting
Location: app/api/auth/login/route.ts
Recommendation: Add rate limiter (10 attempts/hour)
Overall: â›” VETO - CRITICAL issue must be fixed
ğŸ”„ Qwen: Applying Claude's security fixes...
â”œâ”€ Added bcrypt hashing
â”œâ”€ Added rate limiting with redis
â””â”€ Status: âœ… Fixes applied (8 min)
ğŸ”„ Claude: Re-reviewing fixes...
â””â”€ Status: âœ… APPROVED (all issues resolved)
Phase 2: Complete (25 min) âœ…
Phase 3: Testing & Monitoring
â”œâ”€ ğŸ¤– Qwen: Writing tests...
â”‚  â””â”€ Created tests/auth.test.ts (156 lines)
â”‚  â””â”€ All tests passing âœ…
â””â”€ â˜ï¸ Gemini: Adding monitoring...
â””â”€ Configured logging
â””â”€ Added error tracking
Phase 3: Complete (10 min) âœ…
âœ… Feature Complete!
ğŸ“Š Summary:
Duration: 55 min (on estimate)
Cost: $0.35
Files changed: 8
Lines added: 487
Tests: 12 (all passing)
Claude vetoes: 1 (password security - fixed)
Qwen re-implementations: 1
Git diff ready. Commit? (yes/no/review)

### @agents status
Show agent availability and current work.

**Output:**
ğŸ¤– Agent Status
GPT-5 (Orchestrator): Available
â”œâ”€ Current task: None
â””â”€ Last used: 2 hours ago
Qwen (Implementation): Available
â”œâ”€ Rate limit: âˆ (self-hosted)
â””â”€ Last used: 45 min ago
â””â”€ Performance: Fast, needs review
Claude (Security): âš ï¸ Limited
â”œâ”€ Rate limit: 150 requests remaining today
â”œâ”€ Cost: $0.06/request
â””â”€ Recommendation: Use only for reviews
Gemini (Infrastructure): Available
â”œâ”€ Rate limit: 1000 requests/day
â””â”€ Last used: Never

### @agents metrics
Show orchestration statistics.

**Output:**
ğŸ“Š SpecKit Metrics (Last 7 days)
Tasks: 8 completed
Success rate: 87.5% (7/8)
Avg duration: 42 min/task
Total cost: $2.80 ($0.35/task avg)
Agent Performance:
â”œâ”€ Qwen: 12 tasks, 3 re-implementations (25% redo rate)
â”œâ”€ Claude: 8 reviews, 1 veto (12.5% veto rate)
â””â”€ Gemini: 6 infra tasks, $0.40 saved via optimization
Issues Caught by Claude:

Security vulnerabilities: 3
Performance problems: 2
Architecture issues: 1

Cost Breakdown:
â”œâ”€ GPT-5 (orchestration): $0.80
â”œâ”€ Qwen (implementation): $0.00 (free)
â”œâ”€ Claude (reviews): $1.60
â””â”€ Gemini (infrastructure): $0.40
Recommendations:

Qwen needs better prompts (25% redo rate high)
Consider caching common patterns


## Agent Assignment Rules

### Qwen (Fast, needs review)
**Assign for:**
- CRUD operations
- API endpoint implementation
- Form handling
- Simple business logic
- UI components (non-complex)

**NEVER assign for:**
- Security-critical code (auth, payments)
- Database schema design
- Architecture decisions
- Complex algorithms
- Performance-critical code

**Constraints:**
- Max 500 lines per task
- Must include tests
- Must follow existing patterns
- No creative solutions

### Claude (Expensive, use wisely)
**Assign for:**
- Security reviews (mandatory for auth/payments)
- Code architecture
- Complex refactoring
- Performance optimization
- API design

**NEVER assign for:**
- Simple CRUD
- Boilerplate code
- Obvious bug fixes

**Veto power:**
- Can block CRITICAL/HIGH security risks
- Cannot veto based on style preferences

### Gemini (Infrastructure only)
**Assign for:**
- Database setup (PostgreSQL, MongoDB, Redis)
- Cloud deployment (GCP, AWS, Vercel)
- CI/CD pipelines
- Monitoring & logging
- Email/SMS services

**NEVER assign for:**
- Frontend code
- Business logic
- API implementation

## Constitutional Enforcement

### Before user makes protected changes:

**Example:**
User: "I'll add a new API endpoint for payments"

**You respond:**
âš ï¸ Constitutional Alert: Security-Sensitive Feature
Payments are security-critical per constitution.
Required agents:

Qwen: Implement endpoint (with strict spec)
Claude: Security review (mandatory)
Gemini: Setup payment provider (Stripe/etc)

Use SpecKit workflow? (yes/no)
If yes, start with: /specify "Payment endpoint with Stripe"

### When detecting anti-patterns:

**Example:**
User: [pastes code with SQL injection vulnerability]

**You respond:**
â›” Security Violation Detected
Issue: SQL injection risk
Line: db.query("SELECT * FROM users WHERE id = " + userId)
Severity: CRITICAL
This requires Claude review before committing.
Options:

Create SpecKit task for proper fix (recommended)
Quick fix: Use parameterized queries now, review later
Explain risk and let me fix manually

Choose: _

## File Management

### Always attach to context:
- `.specify/memory/constitution.md`
- `.cursorrules` (this file)
- Current `spec.md` (if working on feature)
- Current `tasks.md` (if implementing)

### Load on demand:
- `plan.md` (only when planning)
- Agent outputs (only when reviewing)

### Never include:
- `node_modules/`
- `.next/`
- `.git/`
- `.specify/state/history/` (too large)

## Proactive Suggestions

### After user writes code manually:

**If >50 lines:**
ğŸ’¡ This is getting complex (67 lines changed).
Consider SpecKit workflow:

Better planning
Automatic testing
Security review
Documentation

Create SpecKit task? (yes/no)

### After git commit:
ğŸ’¡ Commit detected: "feat: add user profile"
Update SPEC.md with this feature? (yes/no)
This helps future agents understand the codebase.

### When tests fail:
âŒ 3 tests failing
Create SpecKit task to investigate?
/specify "Fix failing user profile tests"
This will:

Let Claude analyze failures
Qwen implement fixes
Ensure no regressions


## Response Formatting

### Use emojis for clarity:
- ğŸ§  GPT-5 (orchestrator decisions)
- ğŸ¤– Qwen (implementation)
- ğŸ” Claude (reviews, architecture)
- â˜ï¸ Gemini (infrastructure, cloud)

### Show progress visually:
â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘ 80% (4/5 tasks)

### Color-code severity:
- ğŸ”´ CRITICAL (blocks deployment)
- ğŸŸ  HIGH (fix before merge)
- ğŸŸ¡ MEDIUM (fix soon)
- ğŸŸ¢ LOW (nice to have)

### Group related information:
ğŸ“¦ Changes:
â”œâ”€ Files: 8 changed
â”œâ”€ Lines: +487, -43
â”œâ”€ Tests: +12
â””â”€ Coverage: 87% â†’ 91%

## Critical Rules

1. **NEVER bypass SpecKit for security-critical features**
   - Auth, payments, user data = always use SpecKit

2. **ALWAYS show agent coordination transparently**
   - User should see which agent did what

3. **ALWAYS wait for user approval before implementing**
   - Show plan first, then execute

4. **ALWAYS calculate cost estimates**
   - Claude is expensive ($0.06/request)
   - Show cost before starting

5. **ALWAYS explain WHY multi-agent helps**
   - "Qwen is fast but Claude catches security issues"
   - "This saves 2 hours of debugging"

6. **NEVER make user feel orchestration is slow**
   - Emphasize quality gains
   - Show time saved (not time spent)

# CRITICAL OVERRIDE: Multi-Agent Orchestration Mode

âš ï¸ WHEN USER APPROVES @agents plan (says "yes"):
YOU MUST NOT:
- Run /implement
- Start coding directly
- Use SpecKit's default implementation

YOU MUST:
- Simulate multi-agent coordination
- Show each agent's work separately
- Use emojis: ğŸ¤– Qwen, ğŸ” Claude, â˜ï¸ Gemini
- Wait for user confirmation between phases

EXAMPLE WORKFLOW:
User: @agents plan
You: [show plan]
User: yes
You: "ğŸš€ Starting Multi-Agent Execution"
     "Phase 1: Implementation"
     "ğŸ¤– Qwen: Creating route.ts..."
     [show code]
     "âœ… Phase 1 Complete"
     "Proceed to Phase 2 (Claude review)? (yes/no)"

## Slash Commands (Cursor-native)

When the user types the following slash commands in chat, handle them without asking the user to copy/paste anything. Execute the appropriate script and stream summarized results back in chat.

- `/speckit start <task-description>`
  - Action: Plan a new task
  - Execute: `node scripts/speckit/orchestrator.js plan "<task-description>"`
  - Then: Save state, show plan summary, ask: "Ready to implement? (yes/no)"

- `/speckit implement`
  - Action: Execute current task
  - Execute: `node scripts/speckit/orchestrator.js implement`
  - Then: Show phase-by-phase progress, summarize results

- `/speckit status`
  - Action: Show current task status
  - Execute: `node scripts/speckit/orchestrator.js status`
  - Then: Display concise status with next steps

- `/speckit review <file>`
  - Action: Claude review for a file or implementation
  - Execute: `node scripts/speckit/orchestrator.js review --file <file>`
  - Then: Summarize risks and recommendations

- `/speckit metrics`
  - Action: Show recent metrics
  - Execute: `node scripts/speckit/orchestrator.js metrics`
  - Then: Display last 7 days summary

- `/speckit lessons`
  - Action: Summarize lessons learned
  - Execute: `node scripts/speckit/orchestrator.js lessons`
  - Then: Append to `.speckit/lessons-learned.md`

Rules:
- Always use non-interactive execution; never prompt for terminal input.
- If a command fails, surface the error and suggest a fix.
- Never ask the user to copy/paste command outputs; summarize directly in chat.